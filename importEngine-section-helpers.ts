// ============ SECTION 4: STOCK INFO, STYLE PREFIX & HELPERS ============
//
// Consolidated helper functions extracted from routes.ts and importUtils.ts.
// These were previously duplicated across 2-6 locations each.
//

// ============================================================
// calculateItemStockInfo
// ============================================================
// Previously duplicated in:
//   - routes.ts (calculateItemStockInfo)
//   - importUtils.ts (calculateItemStockInfo)
// Logic is identical; routes version used as base (more comments).

/**
 * Calculate the stock info message for a single inventory item based on
 * the active stock-info rule. Returns the appropriate message string or null.
 *
 * Priority order:
 *   1. Expanded size message (if item was generated by size expansion)
 *   2. In-stock message (stock > threshold — always wins over future date)
 *   3. Future date message (stock <= threshold AND shipDate is in the future)
 *   4. Out-of-stock message (fallback)
 */
export function calculateItemStockInfo(
  item: any,
  stockInfoRule: any,
): string | null {
  if (!stockInfoRule) {
    return null;
  }

  const stock = item.stock || 0;
  const shipDate = item.shipDate;
  const isExpandedSize = item.isExpandedSize || false;
  const threshold = stockInfoRule.stockThreshold || 0;

  // Priority 1: Expanded size
  if (isExpandedSize && stockInfoRule.sizeExpansionMessage) {
    return stockInfoRule.sizeExpansionMessage;
  }

  // Priority 2: In stock - ALWAYS takes priority over future date
  // Items with stock > threshold get IN STOCK message regardless of shipDate
  if (stock > threshold) {
    return stockInfoRule.inStockMessage;
  }

  // Priority 3: Has future date - ONLY for zero/low stock items
  // Items with stock <= threshold AND a future shipDate get the future date message
  if (shipDate && stockInfoRule.futureDateMessage) {
    try {
      const dateStr = String(shipDate).trim();
      let targetDate: Date;

      // Parse ISO format: YYYY-MM-DD
      const isoMatch = dateStr.match(/^(\d{4})-(\d{1,2})-(\d{1,2})/);
      // Parse US format: M/D/YYYY
      const usMatch = dateStr.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})/);
      // Parse US short format: M/D/YY
      const usShortMatch = dateStr.match(/^(\d{1,2})\/(\d{1,2})\/(\d{2})$/);

      if (isoMatch) {
        const [, year, month, day] = isoMatch;
        targetDate = new Date(
          parseInt(year),
          parseInt(month) - 1,
          parseInt(day),
        );
      } else if (usMatch) {
        const [, month, day, year] = usMatch;
        targetDate = new Date(
          parseInt(year),
          parseInt(month) - 1,
          parseInt(day),
        );
      } else if (usShortMatch) {
        const [, month, day, shortYear] = usShortMatch;
        targetDate = new Date(
          2000 + parseInt(shortYear),
          parseInt(month) - 1,
          parseInt(day),
        );
      } else {
        targetDate = new Date(dateStr);
      }

      // Apply offset days (supports negative values to pull dates back)
      const offsetDays = stockInfoRule.dateOffsetDays || 0;
      if (offsetDays !== 0) {
        targetDate.setDate(targetDate.getDate() + offsetDays);
      }

      // Check if future
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      targetDate.setHours(0, 0, 0, 0);

      if (targetDate > today) {
        const formattedDate = targetDate.toLocaleDateString("en-US", {
          month: "long",
          day: "numeric",
          year: "numeric",
        });
        return stockInfoRule.futureDateMessage.replace(
          /\{date\}/gi,
          formattedDate,
        );
      }
    } catch (e) {
      console.error(`[Import] Failed to parse date: ${shipDate}`, e);
    }
  }

  // Priority 4: Out of stock
  let outOfStockMsg = stockInfoRule.outOfStockMessage;
  if (outOfStockMsg && outOfStockMsg.includes("{date}")) {
    outOfStockMsg = outOfStockMsg
      .replace(/\{date\}/gi, "")
      .replace(/\s+/g, " ")
      .trim();
  }
  return outOfStockMsg || null;
}

// ============================================================
// getStockInfoRule
// ============================================================
// Previously duplicated in:
//   - routes.ts (getStockInfoRule)
//   - importUtils.ts (getStockInfoRuleForEmail)
// Logic is identical; merged into one function.

/**
 * Resolve the stock-info rule for a data source.
 *
 * Checks two sources in priority order:
 *   1. AI Importer stockInfoConfig (message1InStock, message2ExtraSizes, etc.)
 *   2. Rule Engine metafield rules from the database (snake_case + camelCase)
 *
 * Returns a normalized rule object or null if no rule is configured.
 */
export async function getStockInfoRule(
  dataSource: any,
  storageRef: any,
): Promise<any> {
  let stockInfoRule: any = null;

  try {
    const stockInfoConfig = (dataSource as any).stockInfoConfig;

    // Check if stockInfoConfig has ANY actual messages configured
    const hasStockInfoMessages =
      stockInfoConfig &&
      (stockInfoConfig.message1InStock ||
        stockInfoConfig.message2ExtraSizes ||
        stockInfoConfig.message3Default ||
        stockInfoConfig.message4FutureDate);

    if (hasStockInfoMessages) {
      // Use AI Importer settings - these take priority
      stockInfoRule = {
        id: "ai-importer-config",
        name: "AI Importer Stock Info Config",
        stockThreshold: 0,
        inStockMessage: stockInfoConfig.message1InStock || "",
        sizeExpansionMessage: stockInfoConfig.message2ExtraSizes || null,
        outOfStockMessage: stockInfoConfig.message3Default || "",
        futureDateMessage: stockInfoConfig.message4FutureDate || null,
        dateOffsetDays: stockInfoConfig.dateOffsetDays ?? 0,
        enabled: true,
      };
      console.log(
        `[Import] Using stockInfoConfig: inStock="${stockInfoRule.inStockMessage}"`,
      );
    } else {
      // Fallback to Rule Engine metafield rules
      const metafieldRules =
        await storageRef.getShopifyMetafieldRulesByDataSource(dataSource.id);

      // Use first enabled rule
      const activeDbRule = metafieldRules.find(
        (r: any) => r.enabled !== false,
      );

      if (activeDbRule) {
        // Normalize database rule to handle both snake_case and camelCase
        stockInfoRule = {
          id: activeDbRule.id,
          name: activeDbRule.name || "Rule Engine Metafield Rule",
          stockThreshold:
            activeDbRule.stockThreshold ?? activeDbRule.stock_threshold ?? 0,
          inStockMessage:
            activeDbRule.inStockMessage ||
            activeDbRule.in_stock_message ||
            "",
          sizeExpansionMessage:
            activeDbRule.sizeExpansionMessage ||
            activeDbRule.size_expansion_message ||
            null,
          outOfStockMessage:
            activeDbRule.outOfStockMessage ||
            activeDbRule.out_of_stock_message ||
            "",
          futureDateMessage:
            activeDbRule.futureDateMessage ||
            activeDbRule.future_date_message ||
            null,
          dateOffsetDays:
            activeDbRule.dateOffsetDays ?? activeDbRule.date_offset_days ?? 0,
          enabled: true,
        };
        console.log(
          `[Import] Using Rule Engine metafield rule: inStock="${stockInfoRule.inStockMessage}"`,
        );
      } else {
        console.log(
          `[Import] No stockInfoConfig AND no metafield rules - stockInfo will be null`,
        );
      }
    }
  } catch (ruleError) {
    console.error(`[Import] Failed to get stock info rules:`, ruleError);
  }

  return stockInfoRule;
}

// ============================================================
// getStylePrefix
// ============================================================
// Previously duplicated in 6+ locations:
//   - routes.ts: processUrlDataSourceImport, performCombineImport,
//     /upload handler, /fetch-url handler, /reimport handler
//   - importUtils.ts: processEmailAttachment
//
// All copies share identical core logic. The callers also share a
// common pattern: use item.brand as prefix (for store_multibrand),
// else call getStylePrefix(style), else fall back to dataSource.name.
// This unified version internalizes the brand check.

/**
 * Determine the style prefix for an inventory item.
 *
 * Resolution order:
 *   1. item.brand — if the parser set a brand (e.g. store_multibrand vendor column)
 *   2. Custom prefix rules — dataSource.cleaningConfig.stylePrefixRules
 *      (regex or literal startsWith, case-insensitive)
 *   3. dataSource.name — with "Sale"/"Sales" suffix stripped for sales sources
 */
export function getStylePrefix(item: any, dataSource: any): string {
  // If item has a brand (from store_multibrand vendor column), use brand as prefix
  if (item.brand) {
    return String(item.brand).trim();
  }

  // If no style to match rules against, fall back to data source name
  const style = item.style;
  if (!style) {
    return dataSource.name;
  }

  // Check custom prefix rules from cleaningConfig
  const cleaningConfig = (dataSource.cleaningConfig as any) || {};
  if (
    cleaningConfig.useCustomPrefixes &&
    cleaningConfig.stylePrefixRules &&
    cleaningConfig.stylePrefixRules.length > 0
  ) {
    const rules = cleaningConfig.stylePrefixRules as Array<{
      pattern: string;
      prefix: string;
    }>;
    for (const rule of rules) {
      if (rule.pattern && rule.prefix) {
        try {
          // Use regex matching (case-insensitive)
          const regex = new RegExp(rule.pattern, "i");
          if (regex.test(style)) {
            return rule.prefix;
          }
        } catch (e) {
          // Invalid regex, try literal match as fallback
          if (style.toLowerCase().startsWith(rule.pattern.toLowerCase())) {
            return rule.prefix;
          }
        }
      }
    }
  }

  // Fall back to data source name
  let prefix = dataSource.name;

  // For sale files, strip "Sale" or "Sales" suffix from the prefix
  // This ensures "Jovani Sale 12345" becomes "Jovani 12345" (matching the regular file)
  if ((dataSource as any).sourceType === "sales") {
    const saleMatch = prefix.match(/^(.+?)\s*(Sale|Sales)$/i);
    if (saleMatch) {
      prefix = saleMatch[1].trim();
    }
  }

  return prefix;
}

// ============================================================
// checkSafetyThreshold
// ============================================================
// Previously in routes.ts only, but used by multiple import paths.
// Extracted here so all import paths can share it.

/**
 * Safety-net check that blocks an import if the item count drops by more
 * than a configured percentage compared to the previous import.
 *
 * @param newCount   - Number of items in the incoming import
 * @param previousCount - Number of items from the previous import
 * @param source     - Human-readable label for logging (e.g. "Manual Upload", "URL Import")
 * @param safetyThreshold - Drop percentage threshold (default 50). Set to 0 to disable.
 * @returns Object with `blocked` flag and optional `dropPercent` / `message`
 */
export function checkSafetyThreshold(
  newCount: number,
  previousCount: number,
  source: string,
  safetyThreshold?: number | null,
): { blocked: boolean; dropPercent?: number; message?: string } {
  const threshold = safetyThreshold ?? 50;

  // Disabled or no previous data to compare against
  if (threshold === 0 || previousCount <= 0) {
    return { blocked: false };
  }

  const dropPercent =
    newCount <= 0
      ? 100
      : ((previousCount - newCount) / previousCount) * 100;

  if (dropPercent > threshold) {
    const msg = `SAFETY NET: Item count dropped ${dropPercent.toFixed(0)}% (from ${previousCount} to ${newCount}). Threshold is ${threshold}%. Import blocked to prevent data loss.`;
    console.error(`[${source}] SAFETY BLOCK: ${msg}`);
    return {
      blocked: true,
      dropPercent: Math.round(dropPercent),
      message: msg,
    };
  }

  return { blocked: false };
}
